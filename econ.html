<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VAT GAP 2025 - Persistent Session</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-color: #f8fafc;
            --dot-color: #cbd5e1;
            --accent-color: #6366f1;
            --accent-glow: rgba(99, 102, 241, 0.4);
            --completed-bg: #e0e7ff;
            --completed-stroke: #4338ca;
            --text-main: #1e293b;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            user-select: none;
        }

        /* --- BACKGROUND --- */
        #scene {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            cursor: grab;
            position: relative;
            background-image: radial-gradient(var(--dot-color) 1.5px, transparent 1.5px);
            background-size: 30px 30px;
        }

        #scene:active { cursor: grabbing; }

        #canvas {
            transform-origin: 0 0;
            position: absolute;
            top: 0;
            left: 0;
            transition: transform 0.1s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* --- MERMAID STYLING --- */
        .edgePath .path {
            stroke: #94a3b8 !important;
            stroke-width: 2px !important;
            opacity: 0.7;
        }

        g.node rect, g.node polygon, g.node circle {
            fill: #ffffff !important;
            stroke: #cbd5e1 !important;
            stroke-width: 2px !important;
            rx: 12px !important;
            ry: 12px !important;
            filter: drop-shadow(0 4px 6px rgba(0,0,0,0.05));
        }

        g.node .nodeLabel {
            font-family: 'Inter', sans-serif !important;
            font-weight: 500;
            color: var(--text-main) !important;
            line-height: 1.5;
        }

        g.node:hover rect {
            stroke: var(--accent-color) !important;
            filter: drop-shadow(0 10px 15px rgba(99, 102, 241, 0.15));
            cursor: pointer;
        }

        g.node.completed rect, g.node.completed polygon {
            fill: var(--completed-bg) !important;
            stroke: var(--completed-stroke) !important;
            filter: drop-shadow(0 0 15px var(--accent-glow));
        }
        g.node.completed .nodeLabel {
            color: var(--completed-stroke) !important;
            font-weight: 700;
        }

        /* --- CONTROLS --- */
        .controls {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: flex;
            gap: 15px;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.5);
            border-radius: 20px;
            box-shadow: 0 10px 30px -5px rgba(0, 0, 0, 0.1);
        }

        .btn {
            background: transparent;
            border: none;
            width: 44px;
            height: 44px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 1.4rem;
            color: #475569;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .btn:hover {
            background: #fff;
            color: var(--accent-color);
            transform: scale(1.1);
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }

        /* --- RESET DATA BUTTON --- */
        .reset-data-btn {
            position: fixed;
            bottom: 40px;
            left: 40px;
            z-index: 101;
            background: white;
            border: 1px solid #fee2e2;
            color: #ef4444;
            padding: 10px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 1.2rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            transition: all 0.2s;
        }
        .reset-data-btn:hover {
            background: #fef2f2;
            transform: scale(1.1);
        }

        /* --- DRAWER --- */
        #drawer {
            position: fixed;
            top: 20px;
            right: 20px;
            bottom: 20px;
            width: 450px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 24px;
            box-shadow: -20px 0 50px rgba(0,0,0,0.1);
            transform: translateX(120%);
            transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            z-index: 1000;
            padding: 35px;
            display: flex;
            flex-direction: column;
            border: 1px solid #fff;
        }

        #drawer.open { transform: translateX(0); }

        .drawer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            border-bottom: 1px solid #e2e8f0;
            padding-bottom: 15px;
        }

        .step-content {
            background: #fff;
            padding: 25px;
            border-radius: 16px;
            border: 1px solid #f1f5f9;
            margin-bottom: 25px;
            line-height: 1.6;
            color: #334155;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.05);
        }

        textarea {
            width: 100%;
            flex-grow: 1;
            padding: 20px;
            border: 1px solid #e2e8f0;
            border-radius: 16px;
            resize: none;
            font-family: 'Inter', sans-serif;
            background: #f8fafc;
            outline: none;
            transition: all 0.2s;
        }
        textarea:focus {
            border-color: var(--accent-color);
            background: #fff;
            box-shadow: 0 0 0 4px var(--accent-glow);
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 23, 42, 0.3);
            backdrop-filter: blur(4px);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 999;
        }
        .overlay.active { opacity: 1; pointer-events: all; }

    </style>
</head>
<body>

    <div class="controls">
        <button class="btn" onclick="modifyZoom(1.2)" title="Zoom In">Ôºã</button>
        <button class="btn" onclick="centerNodeA()" title="Reset & Center">‚ü≤</button>
        <button class="btn" onclick="modifyZoom(0.8)" title="Zoom Out">Ôºç</button>
    </div>

    <button class="reset-data-btn" onclick="clearAllData()" title="»òterge tot progresul (Reset)">üóëÔ∏è</button>

    <div id="scene">
        <div id="canvas">
            <div class="mermaid">
%%{
  init: {
    'theme': 'base',
    'themeVariables': {
      'primaryColor': '#ffffff',
      'primaryBorderColor': '#cbd5e1',
      'lineColor': '#94a3b8',
      'fontFamily': 'Inter',
      'fontSize': '16px'
    },
    'flowchart': {
      'curve': 'basis', 
      'nodeSpacing': 200, 
      'rankSpacing': 250, 
      'htmlLabels': true
    }
  }
}%%
flowchart TD
    A[TEMA: GAP TVA 2023 √Æn UE] --> B[1. FUNDAMENTARE TEORETICƒÇ]
    
    B --> B1[CautƒÉ 5-10 articole recente<br/>2020-2025 despre:]
    B1 --> B1a[‚Ä¢ VAT gap determinants]
    B1 --> B1b[‚Ä¢ Shadow economy & tax evasion]
    B1 --> B1c[‚Ä¢ Digitalization impact on tax compliance]
    B1 --> B1d[‚Ä¢ EU tax administration efficiency]
    
    B1 --> C[2. COLECTARE & PREGƒÇTIRE DATE]
    
    C --> C1[Variabila DEPENDENTƒÇ:<br/>VAT_GAP_2023]
    C --> C2[Variabile INDEPENDENTE]
    
    C2 --> C2a[SHADOW_ECONOMY<br/>% din PIB - 2023]
    C2 --> C2b[DIGI_DUMMY<br/>digitalizare timpurie]
    C2 --> C2c[Alte variabile de control]
    
    C2c --> C2c1[‚Ä¢ GDP_per_capita]
    C2c --> C2c2[‚Ä¢ Tax_administration_quality]
    C2c --> C2c3[‚Ä¢ Corruption_index]
    C2c --> C2c4[‚Ä¢ Digital_infrastructure]
    
    C --> D[3. EXPLORATORY DATA ANALYSIS]
    
    D --> D1[Statistici descriptive<br/>mean, sd, min, max, skewness]
    D --> D2[VizualizƒÉri]
    D --> D3[Matrice de corela»õii]
    
    D2 --> D2a[‚Ä¢ Histograme pentru distribu»õii]
    D2 --> D2b[‚Ä¢ Scatter plots VAT_GAP vs predictori]
    D2 --> D2c[‚Ä¢ Boxplots pe grup DIGI_DUMMY]
    
    D --> E[4. √éMPƒÇR»öIRE TRAIN/TEST]
    E --> E1[70-80% TRAIN<br/>20-30% TEST]
    
    E --> F[5. MODELUL DE BAZƒÇ - OLS]
    
    F --> F1[VAT_GAP = Œ≤0 + Œ≤1¬∑SHADOW_ECONOMY<br/>+ Œ≤2¬∑DIGI_DUMMY + Œ≤3¬∑CONTROLS + Œµ]
    
    F1 --> G[6. VALIDƒÇRI OBLIGATORII]
    
    G --> G1[A. SEMNIFICA»öIE STATISTICƒÇ]
    G1 --> G1a[t-test pentru fiecare Œ≤<br/>‚úì p-value < 0.05 sau 0.10]
    G1 --> G1b[F-test global<br/>‚úì modelul e semnificativ]
    
    G --> G2[B. BONITATEA MODELULUI]
    G2 --> G2a[R¬≤ »ôi R¬≤_adjusted<br/>‚úì c√¢t din varia»õie explicƒÉ]
    G2 --> G2b[AIC / BIC<br/>‚úì pentru compara»õii]
    
    G --> G3[C. IPOTEZE CLASICE OLS]
    
    G3 --> H1[TEST 1: NORMALITATE]
    H1 --> H1a[Shapiro-Wilk test pe reziduuri]
    H1 --> H1b[Q-Q plot vizual]
    H1 --> H1c[‚ö†Ô∏è DacƒÉ RESPINS: n mare salveazƒÉ<br/>prin CLT, altfel transformƒÉri]
    
    G3 --> H2[TEST 2: HOMOSCEDASTICITATE]
    H2 --> H2a[Breusch-Pagan test]
    H2 --> H2b[White test]
    H2 --> H2c[Plot reziduuri vs fitted]
    H2 --> H2d[‚ö†Ô∏è DacƒÉ RESPINS:<br/>Corec»õie HC robust std errors]
    
    G3 --> H3[TEST 3: MULTICOLINIARITATE]
    H3 --> H3a[VIF pentru fiecare predictor]
    H3 --> H3b[‚úì VIF < 5 OK<br/>‚ö†Ô∏è VIF > 10 PROBLEMƒÇ]
    H3 --> H3c[DacƒÉ problemƒÉ:<br/>eliminƒÉ variabile corelate<br/>sau centreazƒÉ datele]
    
    G3 --> H4[TEST 4: OUTLIERI & INFLUEN»öƒÇ]
    H4 --> H4a[Cook's Distance > 1]
    H4 --> H4b[Leverage > 2k/n]
    H4 --> H4c[Studentized residuals]
    H4 --> H4d[‚ö†Ô∏è DacƒÉ detectat:<br/>investigheazƒÉ & eventual exclude]
    
    G3 --> H5[TEST 5: SPECIFICA»öIE]
    H5 --> H5a[Ramsey RESET test]
    H5 --> H5b[‚ö†Ô∏è DacƒÉ RESPINS:<br/>adaugƒÉ termeni pƒÉtra»õi/<br/>forme func»õionale]
    
    H1 --> I[7. MODEL √éMBUNƒÇTƒÇ»öIT]
    H2 --> I
    H3 --> I
    H4 --> I
    H5 --> I
    
    I --> I1[FORME FUNC»öIONALE alternative]
    I1 --> I1a[Log-log: log VAT_GAP ~ log SHADOW]
    I1 --> I1b[Semi-log: VAT_GAP ~ log SHADOW]
    I1 --> I1c[PolinomialƒÉ: + SHADOW¬≤]
    
    I --> I2[INTERAC»öIUNI]
    I2 --> I2a[SHADOW √ó DIGI_DUMMY<br/>efectul digitalizƒÉrii modificƒÉ<br/>impactul economiei subterane?]
    
    I --> I3[ComparƒÉ modele cu AIC/BIC<br/>Alege modelul optim]
    
    I3 --> J[8. EVALUARE OUT-OF-SAMPLE]
    
    J --> J1[Predict pe TEST set]
    J --> J2[CalculeazƒÉ metrici:]
    J2 --> J2a[‚Ä¢ RMSE - Root Mean Squared Error]
    J2 --> J2b[‚Ä¢ MAE - Mean Absolute Error]
    J2 --> J2c[‚Ä¢ MAPE - Mean Absolute % Error]
    J2 --> J2d[‚Ä¢ R¬≤ pe test]
    
    J --> K[9. REGULARIZARE & ML]
    
    K --> K1[Ridge Œ± > 0]
    K --> K2[Lasso Œ± > 0]
    K --> K3[Elastic Net]
    K --> K4[Cross-validation pentru Œ± optim]
    
    K --> K5[ComparƒÉ:<br/>OLS vs Ridge vs Lasso]
    K5 --> K5a[Acurate»õe predictivƒÉ RMSE/MAE]
    K5 --> K5b[Interpretabilitate coeficien»õi]
    
    K --> L[10. OP»öIONAL: ML AVANSAT]
    L --> L1[Random Forest]
    L --> L2[Gradient Boosting]
    L --> L3[SVR]
    
    L --> M[11. SCENARIU PROGNOZƒÇ]
    
    M --> M1[Pe modelul optim validat]
    M --> M2[Scenarii ipotetic:]
    M2 --> M2a[Ce se √Ænt√¢mplƒÉ dacƒÉ<br/>shadow economy scade cu 10%?]
    M2 --> M2b[Impact digitalizare √Æn »õƒÉri<br/>fƒÉrƒÉ DIGI_DUMMY=1]
    
    M --> N[12. INTERPRETARE & DISCU»öII]
    
    N --> N1[Validare cu literaturƒÉ]
    N --> N2[Convergen»õe OLS vs ML]
    N --> N3[LimitƒÉri studiu]
    N --> N4[Direc»õii viitoare]
            </div>
        </div>
    </div>

    <div class="overlay" id="overlay" onclick="closeDrawer()"></div>
    <div id="drawer">
        <div class="drawer-header">
            <h2 id="drawer-title" style="margin:0; font-weight:700; color:#1e293b;">Detalii Pas</h2>
            <button onclick="closeDrawer()" style="background:none; border:none; cursor:pointer; font-size:1.5rem; color:#64748b;">&times;</button>
        </div>
        <div class="step-content" id="node-text"></div>
        <label style="font-size:0.85rem; font-weight:600; color:#64748b; margin-bottom:10px; display:block; text-transform:uppercase; letter-spacing:0.5px;">Notele Tale (Auto-Saved)</label>
        <textarea id="user-notes" placeholder="Scrie idei, link-uri sau observa»õii aici..."></textarea>
    </div>

    <script>
        mermaid.initialize({ startOnLoad: true });

        // --- CORE ENGINE ---
        let state = {
            scale: 1.5, // Scara ini»õialƒÉ crescutƒÉ
            x: 0,
            y: 0,
            panning: false,
            startX: 0,
            startY: 0
        };

        const scene = document.getElementById('scene');
        const canvas = document.getElementById('canvas');

        // --- PERSISTENCE LOGIC (LOCALSTORAGE) ---
        const STORAGE_KEY_COMPLETED = "vatgap_completed_nodes";
        const STORAGE_KEY_NOTES = "vatgap_user_notes";
        
        let notesStorage = {}; // Will load from LS

        function loadPersistence() {
            // 1. Load Notes
            const savedNotes = localStorage.getItem(STORAGE_KEY_NOTES);
            if (savedNotes) {
                notesStorage = JSON.parse(savedNotes);
            }

            // 2. Load Completed State (Green nodes)
            const savedCompleted = localStorage.getItem(STORAGE_KEY_COMPLETED);
            if (savedCompleted) {
                const ids = JSON.parse(savedCompleted);
                ids.forEach(id => {
                    const el = document.getElementById(id);
                    if(el) el.classList.add('completed');
                });
            }
        }

        function saveCompletedState() {
            const completedNodes = Array.from(document.querySelectorAll('.node.completed')).map(node => node.id);
            localStorage.setItem(STORAGE_KEY_COMPLETED, JSON.stringify(completedNodes));
        }

        function saveNotesState() {
            localStorage.setItem(STORAGE_KEY_NOTES, JSON.stringify(notesStorage));
        }

        function clearAllData() {
            if(confirm("E»ôti sigur cƒÉ vrei sƒÉ »ôtergi tot progresul »ôi noti»õele?")) {
                localStorage.removeItem(STORAGE_KEY_COMPLETED);
                localStorage.removeItem(STORAGE_KEY_NOTES);
                location.reload();
            }
        }

        function updateTransform() {
            canvas.style.transform = `translate(${state.x}px, ${state.y}px) scale(${state.scale})`;
        }

        // --- FORCED CENTERING LOGIC ---
        function centerNodeA() {
            const nodeA = document.querySelector('g[id^="flowchart-A-"]');
            if (nodeA) {
                const nodeBox = nodeA.getBBox();
                
                // --- AICI ESTE SCHIMBAREA MAJORƒÇ ---
                state.scale = 20; // Era 0.9, acum e 1.5 pentru ZOOM IN
                // -----------------------------------

                const screenW = window.innerWidth;
                const scaledNodeX = (nodeBox.x + nodeBox.width / 2) * state.scale;
                //state.x = (screenW / 2) - scaledNodeX;
                state.x=430;
                //state.y = 100 - (nodeBox.y * state.scale); 
                state.y=185;
                updateTransform();
            } else {
                setTimeout(centerNodeA, 100);
            }
        }

        // Wait for render
        let attempts = 0;
        const initInterval = setInterval(() => {
            const node = document.querySelector('.node');
            if (node) {
                clearInterval(initInterval);
                setTimeout(() => {
                    centerNodeA();
                    loadPersistence(); // LOAD DATA AFTER RENDER
                }, 300);
            }
            if(++attempts > 50) clearInterval(initInterval);
        }, 100);

        // --- ZOOM & PAN ---
        scene.addEventListener('wheel', (e) => {
            e.preventDefault();
            const xs = (e.clientX - state.x) / state.scale;
            const ys = (e.clientY - state.y) / state.scale;
            const delta = -e.deltaY;
            const factor = 1.1;
            (delta > 0) ? (state.scale *= factor) : (state.scale /= factor);
            if(state.scale < 0.1) state.scale = 0.1;
            //if(state.scale > 5) state.scale = 5;
            state.x = e.clientX - xs * state.scale;
            state.y = e.clientY - ys * state.scale;
            updateTransform();
        }, { passive: false });

        let isDragging = false;
        let dragStartTime = 0;

        scene.addEventListener('mousedown', (e) => {
            if(e.target.closest('#drawer') || e.target.closest('.controls') || e.target.closest('.reset-data-btn')) return;
            state.panning = true;
            state.startX = e.clientX - state.x;
            state.startY = e.clientY - state.y;
            isDragging = false;
            dragStartTime = Date.now();
            canvas.style.transition = 'none';
            scene.style.cursor = 'grabbing';
        });

        window.addEventListener('mousemove', (e) => {
            if (!state.panning) return;
            e.preventDefault();
            state.x = e.clientX - state.startX;
            state.y = e.clientY - state.startY;
            updateTransform();
            isDragging = true;
        });

        window.addEventListener('mouseup', (e) => {
            if(state.panning) {
                state.panning = false;
                scene.style.cursor = 'grab';
                canvas.style.transition = 'transform 0.1s cubic-bezier(0.4, 0, 0.2, 1)';
                if (Date.now() - dragStartTime < 200 && !isDragging) handleNodeClick(e);
            }
        });

        function modifyZoom(factor) {
            const cx = window.innerWidth / 2;
            const cy = window.innerHeight / 2;
            const xs = (cx - state.x) / state.scale;
            const ys = (cy - state.y) / state.scale;
            state.scale *= factor;
            state.x = cx - xs * state.scale;
            state.y = cy - ys * state.scale;
            updateTransform();
        }

        // --- INTERACTION ---
        function handleNodeClick(e) {
            const nodeElement = e.target.closest('.node');
            if (nodeElement) {
                nodeElement.classList.toggle('completed');
                saveCompletedState(); // SAVE ON CLICK
            }
        }

        scene.addEventListener('dblclick', (e) => {
            const nodeElement = e.target.closest('.node');
            if (nodeElement) {
                const label = nodeElement.querySelector('.nodeLabel');
                openDrawer(nodeElement.id, label ? label.innerText : "");
            }
        });

        // --- DRAWER ---
        const drawer = document.getElementById('drawer');
        const overlay = document.getElementById('overlay');
        const title = document.getElementById('drawer-title');
        const contentDiv = document.getElementById('node-text');
        const noteArea = document.getElementById('user-notes');
        let currentId = null;

        // Save note on input
        noteArea.addEventListener('input', () => {
            if(currentId) {
                notesStorage[currentId] = noteArea.value;
                saveNotesState(); // SAVE ON TYPING
            }
        });

        function openDrawer(id, content) {
            currentId = id;
            let cleanId = id.split('-')[1] || "Info";
            title.textContent = "Pasul: " + cleanId;
            contentDiv.innerHTML = content.replace(/\n/g, "<br>");
            noteArea.value = notesStorage[id] || "";
            drawer.classList.add('open');
            overlay.classList.add('active');
        }

        function closeDrawer() {
            drawer.classList.remove('open');
            overlay.classList.remove('active');
            currentId = null;
        }
    </script>
</body>
</html>