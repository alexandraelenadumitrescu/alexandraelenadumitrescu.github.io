<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blood Type Game 3D (Three.js)</title>
    <link href="https://fonts.googleapis.com/css2?family=MedievalSharp&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'MedievalSharp', cursive, Arial, sans-serif; /* Set global font */
            color: #f5f5dc; /* Set global text color */
        }
        canvas {
            display: block;
            position: absolute; /* Canvas fills the whole screen */
            top: 0;
            left: 0;
            z-index: 0; /* Background layer */
        }
        #info {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #e0b34d; /* Gold color for instruction */
            font-family: 'MedievalSharp', cursive, sans-serif;
            font-size: 2em; /* Larger instruction */
            text-align: center;
            text-shadow: 2px 2px 5px rgba(0, 0, 0, 0.7);
            z-index: 10; /* Above canvas */
            width: 80%; /* Ensure it doesn't wrap awkwardly */
            pointer-events: none; /* Allows clicks to pass through to the canvas */
        }
        #controls-2d {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10; /* Above canvas */
            background: rgba(43, 0, 0, 0.8); /* Dark blood red with transparency */
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #5a0000;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5);
            text-align: center;
        }
        #controls-2d h2 {
            font-family: 'MedievalSharp', cursive, sans-serif;
            color: #e0b34d;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.6);
            margin-bottom: 20px;
            font-size: 1.8em;
        }
        button {
            background-color: #8b0000; /* Vampire dark red */
            color: #f5f5dc; /* Off-white text */
            padding: 15px 30px; /* Larger buttons */
            border: 2px solid #a00000; /* Lighter red border */
            border-radius: 8px; /* Slightly rounded corners */
            font-size: 1.2em; /* Larger font */
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            margin: 8px;
            font-family: 'MedievalSharp', cursive, sans-serif;
            box-shadow: 3px 3px 8px rgba(0, 0, 0, 0.4);
        }
        button:hover {
            background-color: #a00000;
            transform: translateY(-2px);
            box-shadow: 5px 5px 12px rgba(0, 0, 0, 0.6);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.3);
        }
        select {
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #5a0000;
            margin: 0 12px 20px;
            font-size: 1.1em;
            background-color: #3a1a1a;
            color: #f5f5dc;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23f5f5dc%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13.2-6.5H18.5c-4.9%200-9.2%202.4-11.5%206.5l133.5%20141.8c3.6%203.6%208%205.5%2012.8%205.5s9.2-1.9%2012.8-5.5L287%2069.4z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 10px center;
            background-size: 12px;
            cursor: pointer;
        }
        select option {
            background-color: #3a1a1a;
            color: #f5f5dc;
        }
        #feedback {
            margin-top: 15px;
            font-size: 1.2em;
            font-weight: bold;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7);
        }
        .correct { color: #4CAF50; }
        .incorrect { color: #f44336; }
    </style>
</head>
<body>
    <div id="info">Click on the test papers to add blood!</div>
    <div id="controls-2d">
        <h2>Guess the Blood Type:</h2>
        <select id="bloodTypeSelect">
            <option value="">Choose Type</option>
            <option value="A">A</option>
            <option value="B">B</option>
            <option value="AB">AB</option>
            <option value="O">O</option>
        </select>
        <select id="rhFactorSelect">
            <option value="">Choose Rh</option>
            <option value="Positive">Positive</option>
            <option value="Negative">Negative</option>
        </select>
        <button id="checkButton">Check</button>
        <div id="feedback"></div>
        <button id="resetButton" style="display:none;">New Test</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.165.0/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.min.js"></script>

    <script>
        // --- Three.js Setup ---
        let scene, camera, renderer;
        let testPapers = [];
        let bloodDrops = {}; // Map to store Three.js Mesh objects for blood drops
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        const agglutinationRules = {
            'A+': { A: true, B: false, D: true },
            'A-': { A: true, B: false, D: false },
            'B+': { A: false, B: true, D: true },
            'B-': { A: false, B: true, D: false },
            'AB+': { A: true, B: true, D: true },
            'AB-': { A: true, B: true, D: false },
            'O+': { A: false, B: false, D: true },
            'O-': { A: false, B: false, D: false }
        };
        let currentBloodType = {};
        let bloodAddedCount = 0;
        let allowAddingBlood = true; // Control flag for adding blood

        const mainInstruction = document.getElementById('info');
        const feedbackDiv = document.getElementById('feedback');
        const checkButton = document.getElementById('checkButton');
        const resetButton = document.getElementById('resetButton');
        const bloodTypeSelect = document.getElementById('bloodTypeSelect');
        const rhFactorSelect = document.getElementById('rhFactorSelect');
        const controls2D = document.getElementById('controls-2d');

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a); // Match body background

            // Camera (Adjusted for better view)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 4, 5); // Position camera slightly higher and closer
            camera.lookAt(0, 0.5, 0); // Look slightly above the center of the papers

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Lights (More pronounced for visibility)
            const ambientLight = new THREE.AmbientLight(0x404040, 2); // Soft white light, slightly brighter
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 3); // White light from top, brighter
            directionalLight.position.set(0, 10, 5);
            directionalLight.target.position.set(0, 0, 0);
            scene.add(directionalLight);
            scene.add(directionalLight.target);

            // Optional: Add a subtle point light for highlights (vampire theme)
            const pointLight = new THREE.PointLight(0xff0000, 1, 10); // Reddish glow
            pointLight.position.set(0, 3, 0);
            scene.add(pointLight);

            // Textures for paper (using the provided textures)
            const textureLoader = new THREE.TextureLoader();
            const paperTexture = textureLoader.load('https://www.transparenttextures.com/patterns/cream-paper.png');
            paperTexture.wrapS = THREE.RepeatWrapping;
            paperTexture.wrapT = THREE.RepeatWrapping;
            paperTexture.repeat.set(0.5, 0.5); // Adjust repeat for better tiling on smaller papers

            // Create Test Papers
            // Use a material that reacts to light for depth
            const paperMaterial = new THREE.MeshPhongMaterial({ color: 0x3a1a1a, map: paperTexture, shininess: 5 }); // Phong for shininess

            const positions = [
                { x: -2.5, y: 0, z: 0, label: 'Anti-A', id: 'dropA' },
                { x: 0, y: 0, z: 0, label: 'Anti-B', id: 'dropB' },
                { x: 2.5, y: 0, z: 0, label: 'Anti-D (Rh)', id: 'dropD' }
            ];

            positions.forEach(pos => {
                const paperGeometry = new THREE.BoxGeometry(2, 0.05, 2); // Thinner paper
                const paper = new THREE.Mesh(paperGeometry, paperMaterial);
                paper.position.set(pos.x, pos.y, pos.z);
                paper.rotation.x = Math.PI / 18; // Slight tilt
                paper.rotation.y = Math.PI / 36;
                paper.userData = { id: pos.id, hasBlood: false }; // Custom data
                scene.add(paper);
                testPapers.push(paper);

                // Create placeholder for blood drop, hidden initially
                const bloodGeometry = new THREE.SphereGeometry(0.4, 32, 16); // Slightly smaller, less flat
                const bloodMaterial = new THREE.MeshPhongMaterial({ color: 0x8b0000, transparent: true, opacity: 0.9, shininess: 30 }); // More realistic blood
                const blood = new THREE.Mesh(bloodGeometry, bloodMaterial);
                blood.position.set(pos.x, pos.y + 0.1, pos.z); // Slightly above paper
                blood.scale.set(0.01, 0.01, 0.01); // Invisible initially
                blood.visible = false;
                bloodDrops[pos.id] = blood;
                scene.add(blood);
            });

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('click', onDocumentClick, false);

            resetGame(); // Initial setup
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onDocumentClick(event) {
            if (!allowAddingBlood) return;

            // Calculate mouse position in normalized device coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Calculate objects intersecting the picking ray
            const intersects = raycaster.intersectObjects(testPapers);

            if (intersects.length > 0) {
                const clickedPaper = intersects[0].object;
                if (!clickedPaper.userData.hasBlood) {
                    addBloodDrop(clickedPaper.userData.id);
                    clickedPaper.userData.hasBlood = true;
                }
            }
        }

        function addBloodDrop(dropId) {
            const drop = bloodDrops[dropId];
            if (drop) {
                drop.visible = true;
                // Animate drop appearance (scale from small to full)
                new TWEEN.Tween(drop.scale)
                    .to({ x: 1, y: 1, z: 1 }, 500)
                    .easing(TWEEN.Easing.Back.Out)
                    .start();
                bloodAddedCount++;

                if (bloodAddedCount === 3) {
                    mainInstruction.textContent = "All blood drops added. Observing reactions...";
                    setTimeout(startAgglutinationProcess, 1000);
                }
            }
        }

        function startAgglutinationProcess() {
            allowAddingBlood = false;
            const bloodTypes = Object.keys(agglutinationRules);
            const randomType = bloodTypes[Math.floor(Math.random() * bloodTypes.length)];
            currentBloodType.full = randomType;
            currentBloodType.type = randomType.slice(0, -1);
            currentBloodType.rh = randomType.slice(-1) === '+' ? 'Positive' : 'Negative';

            const agglA = agglutinationRules[randomType].A;
            const agglB = agglutinationRules[randomType].B;
            const agglD = agglutinationRules[randomType].D;

            // Start agglutination animations with delays
            setTimeout(() => {
                if (agglA) animateAgglutination(bloodDrops.dropA);
            }, 500);

            setTimeout(() => {
                if (agglB) animateAgglutination(bloodDrops.dropB);
            }, 1500);

            setTimeout(() => {
                if (agglD) animateAgglutination(bloodDrops.dropD);
                // After last animation, show guess controls
                setTimeout(() => {
                    controls2D.style.display = 'block';
                    mainInstruction.textContent = "Observe the mysterious agglutination reactions and unveil the secret of the blood.";
                }, 1000);
            }, 2500);
        }

        function animateAgglutination(dropMesh) {
            // Change color to agglutinated (orange-red)
            new TWEEN.Tween(dropMesh.material.color)
                .to(new THREE.Color(0xe67e22), 2000)
                .start();

            // Simulate "granules" - a more sophisticated approach would be needed for true 3D particles.
            // For now, we simulate a pulsing glow/scale change and slight opacity change.
            new TWEEN.Tween(dropMesh.scale)
                .to({ x: 1.08, y: 1.08, z: 1.08 }, 1000)
                .yoyo(true)
                .repeat(Infinity)
                .start();

            new TWEEN.Tween(dropMesh.material)
                .to({ opacity: 0.8 }, 1000) // Slight opacity change to make it look different
                .yoyo(true)
                .repeat(Infinity)
                .start();

            // Add a temporary glow effect (using a point light, might be overkill for each drop)
            // Or better, adjust shininess/emissive properties.
            // For simplicity, we just rely on the color change and scale for visual cue.
        }

        function checkAnswer() {
            const userBloodType = bloodTypeSelect.value;
            const userRhFactor = rhFactorSelect.value;

            if (!userBloodType || !userRhFactor) {
                feedbackDiv.textContent = 'Please select both blood type and Rh factor!';
                feedbackDiv.className = 'incorrect'; // Use class for styling
                return;
            }

            const guessedFullType = userBloodType + (userRhFactor === 'Positive' ? '+' : '-');

            if (guessedFullType === currentBloodType.full) {
                feedbackDiv.textContent = `Correct! The blood type is ${currentBloodType.type}${currentBloodType.rh === 'Positive' ? '+' : '-'}.`;
                feedbackDiv.className = 'correct';
            } else {
                feedbackDiv.textContent = `Incorrect. The blood type is ${currentBloodType.type}${currentBloodType.rh === 'Positive' ? '+' : '-'}. You guessed ${userBloodType}${userRhFactor === 'Positive' ? '+' : '-'}.`;
                feedbackDiv.className = 'incorrect';
            }
            resetButton.style.display = 'block';
        }

        function resetGame() {
            mainInstruction.textContent = 'Click on each test paper to add blood!';
            feedbackDiv.textContent = '';
            controls2D.style.display = 'none'; // Hide guess controls
            resetButton.style.display = 'none';
            bloodTypeSelect.value = '';
            rhFactorSelect.value = '';
            bloodAddedCount = 0;
            allowAddingBlood = true;

            testPapers.forEach(paper => {
                paper.userData.hasBlood = false;
            });
            for (const id in bloodDrops) {
                const drop = bloodDrops[id];
                drop.visible = false;
                drop.scale.set(0.01, 0.01, 0.01);
                // Reset material properties and stop ongoing tweens
                drop.material.color.set(0x8b0000); // Original blood color
                drop.material.opacity = 0.9; // Reset opacity
                TWEEN.removeAll(); // Stop all tweens to ensure a clean reset for next game
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update(); // Update tweens for animations
            renderer.render(scene, camera);
        }

        // --- Initialize the Game ---
        init();

        // --- UI Event Listeners ---
        checkButton.addEventListener('click', checkAnswer);
        resetButton.addEventListener('click', resetGame);
    </script>
</body>
</html>