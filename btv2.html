<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blood Type Game 3D (Three.js)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-family: Arial, sans-serif;
            font-size: 1.5em;
            text-align: center;
            z-index: 10;
        }
        #controls-2d {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 10px;
            color: white;
        }
        button {
            background-color: #8b0000;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background-color: #a00000;
        }
    </style>
</head>
<body>
    <div id="info">Click on the test papers to add blood!</div>
    <div id="controls-2d">
        <select id="bloodTypeSelect">
            <option value="">Choose Type</option>
            <option value="A">A</option>
            <option value="B">B</option>
            <option value="AB">AB</option>
            <option value="O">O</option>
        </select>
        <select id="rhFactorSelect">
            <option value="">Choose Rh</option>
            <option value="Positive">Positive</option>
            <option value="Negative">Negative</option>
        </select>
        <button id="checkButton">Check</button>
        <div id="feedback"></div>
        <button id="resetButton" style="display:none;">New Test</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.165.0/three.min.js"></script>
    <script>
        // --- Three.js Setup ---
        let scene, camera, renderer;
        let testPapers = [];
        let bloodDrops = {};
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        const agglutinationRules = {
            'A+': { A: true, B: false, D: true },
            'A-': { A: true, B: false, D: false },
            'B+': { A: false, B: true, D: true },
            'B-': { A: false, B: true, D: false },
            'AB+': { A: true, B: true, D: true },
            'AB-': { A: true, B: true, D: false },
            'O+': { A: false, B: false, D: true },
            'O-': { A: false, B: false, D: false }
        };
        let currentBloodType = {};
        let bloodAddedCount = 0;
        let allowAddingBlood = true;

        const mainInstruction = document.getElementById('info');
        const feedbackDiv = document.getElementById('feedback');
        const checkButton = document.getElementById('checkButton');
        const resetButton = document.getElementById('resetButton');
        const bloodTypeSelect = document.getElementById('bloodTypeSelect');
        const rhFactorSelect = document.getElementById('rhFactorSelect');
        const guessSection = document.getElementById('controls-2d'); // Using this as the guess section now

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a); // Match body background

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 3, 5); // Position camera above the papers
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 2); // Soft white light
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2); // White light from top
            directionalLight.position.set(0, 10, 5);
            directionalLight.target.position.set(0, 0, 0);
            scene.add(directionalLight);
            scene.add(directionalLight.target);

            // Textures for paper
            const textureLoader = new THREE.TextureLoader();
            const paperTexture = textureLoader.load('https://www.transparenttextures.com/patterns/cream-paper.png');
            paperTexture.wrapS = THREE.RepeatWrapping;
            paperTexture.wrapT = THREE.RepeatWrapping;
            paperTexture.repeat.set(1, 1); // Adjust repeat if needed

            // Create Test Papers
            const paperGeometry = new THREE.BoxGeometry(2, 0.1, 2); // Flat box for paper
            const paperMaterial = new THREE.MeshLambertMaterial({ color: 0x3a1a1a, map: paperTexture });

            const positions = [
                { x: -2.5, y: 0, z: 0, label: 'Anti-A', id: 'dropA' },
                { x: 0, y: 0, z: 0, label: 'Anti-B', id: 'dropB' },
                { x: 2.5, y: 0, z: 0, label: 'Anti-D (Rh)', id: 'dropD' }
            ];

            positions.forEach(pos => {
                const paper = new THREE.Mesh(paperGeometry, paperMaterial);
                paper.position.set(pos.x, pos.y, pos.z);
                paper.rotation.x = Math.PI / 18; // Slight tilt
                paper.rotation.y = Math.PI / 36;
                paper.userData = { id: pos.id, hasBlood: false }; // Custom data
                scene.add(paper);
                testPapers.push(paper);

                // Create placeholder for blood drop, hidden initially
                const bloodGeometry = new THREE.SphereGeometry(0.5, 32, 16); // Round drop
                const bloodMaterial = new THREE.MeshLambertMaterial({ color: 0x8b0000 });
                const blood = new THREE.Mesh(bloodGeometry, bloodMaterial);
                blood.position.set(pos.x, pos.y + 0.1, pos.z); // Slightly above paper
                blood.scale.set(0.01, 0.01, 0.01); // Invisible initially
                blood.visible = false;
                bloodDrops[pos.id] = blood;
                scene.add(blood);
            });

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('click', onDocumentClick, false);

            resetGame(); // Initial setup
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onDocumentClick(event) {
            if (!allowAddingBlood) return;

            // Calculate mouse position in normalized device coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            // Update the picking ray with the camera and mouse position
            raycaster.setFromCamera(mouse, camera);

            // Calculate objects intersecting the picking ray
            const intersects = raycaster.intersectObjects(testPapers);

            if (intersects.length > 0) {
                const clickedPaper = intersects[0].object;
                if (!clickedPaper.userData.hasBlood) {
                    addBloodDrop(clickedPaper.userData.id);
                    clickedPaper.userData.hasBlood = true;
                }
            }
        }

        function addBloodDrop(dropId) {
            const drop = bloodDrops[dropId];
            if (drop) {
                drop.visible = true;
                // Animate drop appearance
                new TWEEN.Tween(drop.scale)
                    .to({ x: 1, y: 1, z: 1 }, 500) // Scale to full size
                    .easing(TWEEN.Easing.Back.Out)
                    .start();
                bloodAddedCount++;

                if (bloodAddedCount === 3) {
                    mainInstruction.textContent = "All blood drops added. Observing reactions...";
                    setTimeout(startAgglutinationProcess, 1000);
                }
            }
        }

        function startAgglutinationProcess() {
            allowAddingBlood = false;
            const bloodTypes = Object.keys(agglutinationRules);
            const selectedType = bloodTypes[Math.floor(Math.random() * bloodTypes.length)];
            currentBloodType.full = selectedType;
            currentBloodType.type = selectedType.slice(0, -1);
            currentBloodType.rh = selectedType.slice(-1) === '+' ? 'Positive' : 'Negative';

            const agglA = agglutinationRules[selectedType].A;
            const agglB = agglutinationRules[selectedType].B;
            const agglD = agglutinationRules[selectedType].D;

            setTimeout(() => {
                if (agglA) animateAgglutination(bloodDrops.dropA);
            }, 500);

            setTimeout(() => {
                if (agglB) animateAgglutination(bloodDrops.dropB);
            }, 1500);

            setTimeout(() => {
                if (agglD) animateAgglutination(bloodDrops.dropD);
                setTimeout(() => {
                    guessSection.style.display = 'block';
                }, 1000);
            }, 2500);
        }

        function animateAgglutination(dropMesh) {
            // Change color
            new TWEEN.Tween(dropMesh.material.color)
                .to({ r: new THREE.Color(0xe67e22).r, g: new THREE.Color(0xe67e22).g, b: new THREE.Color(0xe67e22).b }, 2000)
                .start();

            // Simulate "granules" by perhaps changing geometry or adding particles
            // For simplicity here, we just change color. More complex would be particle systems etc.
            // A simple scale pulse as before:
            new TWEEN.Tween(dropMesh.scale)
                .to({ x: 1.08, y: 1.08, z: 1.08 }, 1000)
                .yoyo(true)
                .repeat(Infinity) // Keep pulsing
                .start();
        }

        function checkAnswer() {
            const userBloodType = bloodTypeSelect.value;
            const userRhFactor = rhFactorSelect.value;

            if (!userBloodType || !userRhFactor) {
                feedbackDiv.textContent = 'Please select both blood type and Rh factor!';
                feedbackDiv.style.color = '#f44336';
                return;
            }

            const guessedFullType = userBloodType + (userRhFactor === 'Positive' ? '+' : '-');

            if (guessedFullType === currentBloodType.full) {
                feedbackDiv.textContent = `Correct! The blood type is ${currentBloodType.type}${currentBloodType.rh === 'Positive' ? '+' : '-'}.`;
                feedbackDiv.style.color = '#4CAF50';
            } else {
                feedbackDiv.textContent = `Incorrect. The blood type is ${currentBloodType.type}${currentBloodType.rh === 'Positive' ? '+' : '-'}. You guessed ${userBloodType}${userRhFactor === 'Positive' ? '+' : '-'}.`;
                feedbackDiv.style.color = '#f44336';
            }
            resetButton.style.display = 'block';
        }

        function resetGame() {
            mainInstruction.textContent = 'Click on each test paper to add a blood drop!';
            feedbackDiv.textContent = '';
            guessSection.style.display = 'none';
            resetButton.style.display = 'none';
            bloodTypeSelect.value = '';
            rhFactorSelect.value = '';
            bloodAddedCount = 0;
            allowAddingBlood = true;

            testPapers.forEach(paper => {
                paper.userData.hasBlood = false;
            });
            for (const id in bloodDrops) {
                bloodDrops[id].visible = false;
                bloodDrops[id].scale.set(0.01, 0.01, 0.01);
                // Reset material color and stop existing tweens
                bloodDrops[id].material.color.set(0x8b0000); // Original blood color
                TWEEN.removeAll(); // Stop all existing tweens for clean reset
            }
        }


        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update(); // Update tweens for animations
            renderer.render(scene, camera);
        }

        // --- Initialize the Game ---
        init();

        // --- UI Event Listeners ---
        checkButton.addEventListener('click', checkAnswer);
        resetButton.addEventListener('click', resetGame);
    </script>
</body>
</html>